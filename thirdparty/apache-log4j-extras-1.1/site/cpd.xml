<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="1407" tokens="4713">
<file line="270" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/LogMF.java"/>
<file line="135" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/LogSF.java"/>
<codefragment>
<![CDATA[
    private static final String FQCN = LogSF.class.getName();

    /**
     * Equivalent of Logger.forcedLog.
     *
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param msg message, may be null.
     */
    private static void forcedLog(final Logger logger,
                                  final Level level,
                                  final String msg) {
        logger.callAppenders(new LoggingEvent(FQCN, logger, level, msg, null));
    }

    /**
     * Equivalent of Logger.forcedLog.
     *
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param msg message, may be null.
     * @param t throwable.
     */
    private static void forcedLog(final Logger logger,
                                  final Level level,
                                  final String msg,
                                  final Throwable t) {
        logger.callAppenders(new LoggingEvent(FQCN, logger, level, msg, t));
    }
    /**
         * Log a parameterized message at trace level.
         * @param logger logger, may not be null.
         * @param pattern pattern, may be null.
         * @param arguments an array of arguments to be
         *          formatted and substituted.
         */
    public static void trace(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at error level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void error(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.ERROR)) {
            forcedLog(logger, Level.ERROR, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at fatal level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void fatal(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.FATAL)) {
            forcedLog(logger, Level.FATAL, format(pattern, arguments));
        }
    }

    /**
         * Log a parameterized message at trace level.
         * @param logger logger, may not be null.
         * @param t throwable, may be null.
         * @param pattern pattern, may be null.
         * @param arguments an array of arguments to be
         *          formatted and substituted.
         */
    public static void trace(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void debug(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void info(final Logger logger,
                            final Throwable t,
                            final String pattern,
        final Object[] arguments) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void warn(final Logger logger,
                            final Throwable t,
                            final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at error level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void error(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.ERROR)) {
            forcedLog(logger, Level.ERROR, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at fatal level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void fatal(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.FATAL)) {
            forcedLog(logger, Level.FATAL, format(pattern, arguments), t);
        }
    }



    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE,
                    format(pattern, toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG,
                    format(pattern, toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern,
                    toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern,
                    toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern,
                    toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param parameters parameters to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, parameters));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
     * @param t throwable, may be null.
      * @param pattern pattern, may be null.
     * @param parameters parameters to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final Throwable t,
                             final String pattern,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, parameters), t);
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final Object param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(param1)));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final boolean param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final byte param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final char param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final short param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final int param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final long param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final float param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final double param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
     * Log a parameterized message at specified level.
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void log(final Logger logger,
                            final Level level,
                            final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at specifed level.
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void log(final Logger logger,
                           final Level level,
                           final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at specified level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param level level, may not be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void log(final Logger logger,
                           final Level level,
                           final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level, format(pattern,
                    toArray(arg0, arg1, arg2, arg3)));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param parameters parameters to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, parameters));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
     * @param t throwable, may be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param parameters parameters to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final Throwable t,
                             final String bundleName,
                             final String key,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, parameters), t);
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(param1)));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final boolean param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final char param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final byte param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final short param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final int param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final long param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }
    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final float param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final double param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param0 Parameter to the log message.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param0,
                             final Object param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(param0, param1)));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param0 Parameter to the log message.
     * @param param1 Parameter to the log message.
     * @param param2 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param0,
                             final Object param1,
                             final Object param2) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(param0, param1, param2)));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param0 Parameter to the log message.
     * @param param1 Parameter to the log message.
     * @param param2 Parameter to the log message.
     * @param param3 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param0,
                             final Object param1,
                             final Object param2,
                             final Object param3) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key,
                            toArray(param0, param1, param2, param3)));
        }
    }
}
]]>
</codefragment>
</duplication>
<duplication lines="393" tokens="1551">
<file line="100" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/extras/XSLTLayout.java"/>
<file line="96" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/xml/XSLTLayout.java"/>
<codefragment>
<![CDATA[
        implements UnrecognizedElementHandler {
    /**
     * Namespace for XSLT.
     */
    private static final String XSLT_NS = "http://www.w3.org/1999/XSL/Transform";
    /**
     * Namespace for log4j events.
     */
    private static final String LOG4J_NS = "http://jakarta.apache.org/log4j/";
    /**
     * Whether location information should be written.
     */
    private boolean locationInfo = false;
    /**
     * media-type (mime type) extracted from XSLT transform.
     */
    private String mediaType = "text/plain";
    /**
     * Encoding extracted from XSLT transform.
     */
    private Charset encoding;
    /**
     * Transformer factory.
     */
    private SAXTransformerFactory transformerFactory;
    /**
     * XSLT templates.
     */
    private Templates templates;
    /**
     * Output stream.
     */
    private final ByteArrayOutputStream outputStream;
    /**
     * Whether throwable information should be ignored.
     */
    private boolean ignoresThrowable = false;
    /**
     * Whether properties should be extracted.
     */
    private boolean properties = true;
    /**
     * Whether activateOptions has been called.
     */
    private boolean activated = false;

    /**
     * DateFormat for UTC time.
     */
    private final CachedDateFormat utcDateFormat;

    /**
     * Default constructor.
     *
     */
    public XSLTLayout() {
        outputStream = new ByteArrayOutputStream();
        transformerFactory = (SAXTransformerFactory)
                TransformerFactory.newInstance();

        SimpleDateFormat zdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
        zdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        utcDateFormat = new CachedDateFormat(zdf, 1000);
    }

    /**
     * {@inheritDoc}
     */
    public synchronized String getContentType() {
        return mediaType;
    }

    /**
     * The <b>LocationInfo </b> option takes a boolean value. By default, it is
     * set to false which means there will be no location information output by
     * this layout. If the the option is set to true, then the file name and line
     * number of the statement at the origin of the log statement will be output.
     *
     * <p>
     * If you are embedding this layout within an {@link
     * org.apache.log4j.net.SMTPAppender} then make sure to set the
     * <b>LocationInfo </b> option of that appender as well.
     *
     * @param flag new value.
     */
    public synchronized void setLocationInfo(final boolean flag) {
      locationInfo = flag;
    }

    /**
     * Gets whether location info should be output.
     * @return if location is output.
     */
    public synchronized boolean getLocationInfo() {
      return locationInfo;
    }

    /**
     * Sets whether MDC key-value pairs should be output, default false.
     * @param flag new value.
     */
    public synchronized void setProperties(final boolean flag) {
      properties = flag;
    }

    /**
     * Gets whether MDC key-value pairs should be output.
     * @return true if MDC key-value pairs are output.
     */
    public synchronized boolean getProperties() {
      return properties;
    }


    /** {@inheritDoc} */
    public synchronized void activateOptions() {
        if (templates == null) {
            try {
                InputStream is = XSLTLayout.class.getResourceAsStream("default.xslt");
                StreamSource ss = new StreamSource(is);
                templates = transformerFactory.newTemplates(ss);
                encoding = Charset.forName("US-ASCII");
                mediaType = "text/plain";
            } catch (Exception ex) {
                LogLog.error("Error loading default.xslt", ex);
            }
        }
        activated = true;
    }

    /**
     * Gets whether throwables should not be output.
     * @return true if throwables should not be output.
     */
    public synchronized boolean ignoresThrowable() {
        return ignoresThrowable;
    }

    /**
     * Sets whether throwables should not be output.
     * @param ignoresThrowable if true, throwables should not be output.
    */
    public synchronized void setIgnoresThrowable(boolean ignoresThrowable) {
      this.ignoresThrowable = ignoresThrowable;
    }



    /**
     * {@inheritDoc}
     */
    public synchronized String format(final LoggingEvent event) {
      if (!activated) {
          activateOptions();
      }
      if (templates != null && encoding != null) {
          outputStream.reset();

          try {
            TransformerHandler transformer =
                      transformerFactory.newTransformerHandler(templates);

            transformer.setResult(new StreamResult(outputStream));
            transformer.startDocument();

            //
            //   event element
            //
            AttributesImpl attrs = new AttributesImpl();
            attrs.addAttribute(null, "logger", "logger",
                    "CDATA", event.getLoggerName());
            attrs.addAttribute(null, "timestamp", "timestamp",
                    "CDATA", Long.toString(event.timeStamp));
            attrs.addAttribute(null, "level", "level",
                    "CDATA", event.getLevel().toString());
            attrs.addAttribute(null, "thread", "thread",
                    "CDATA", event.getThreadName());
            StringBuffer buf = new StringBuffer();
            utcDateFormat.format(event.timeStamp, buf);
            attrs.addAttribute(null, "time", "time", "CDATA", buf.toString());


            transformer.startElement(LOG4J_NS, "event", "event", attrs);
            attrs.clear();

            //
            //   message element
            //
            transformer.startElement(LOG4J_NS, "message", "message", attrs);
            String msg = event.getRenderedMessage();
            if (msg != null && msg.length() > 0) {
                transformer.characters(msg.toCharArray(), 0, msg.length());
            }
            transformer.endElement(LOG4J_NS, "message", "message");

            //
            //    NDC element
            //
            String ndc = event.getNDC();
            if (ndc != null) {
                transformer.startElement(LOG4J_NS, "NDC", "NDC", attrs);
                char[] ndcChars = ndc.toCharArray();
                transformer.characters(ndcChars, 0, ndcChars.length);
                transformer.endElement(LOG4J_NS, "NDC", "NDC");
            }

            //
            //    throwable element unless suppressed
            //
              if (!ignoresThrowable) {
                String[] s = event.getThrowableStrRep();
                if (s != null) {
                    transformer.startElement(LOG4J_NS, "throwable",
                            "throwable", attrs);
                    char[] nl = new char[] { '\n' };
                    for (int i = 0; i < s.length; i++) {
                        char[] line = s[i].toCharArray();
                        transformer.characters(line, 0, line.length);
                        transformer.characters(nl, 0, nl.length);
                    }
                    transformer.endElement(LOG4J_NS, "throwable", "throwable");
                }
              }

              //
              //     location info unless suppressed
              //
              //
              if (locationInfo) {
                LocationInfo locationInfo = event.getLocationInformation();
                attrs.addAttribute(null, "class", "class", "CDATA",
                        locationInfo.getClassName());
                attrs.addAttribute(null, "method", "method", "CDATA",
                          locationInfo.getMethodName());
                attrs.addAttribute(null, "file", "file", "CDATA",
                            locationInfo.getFileName());
                attrs.addAttribute(null, "line", "line", "CDATA",
                            locationInfo.getLineNumber());
                transformer.startElement(LOG4J_NS, "locationInfo",
                        "locationInfo", attrs);
                transformer.endElement(LOG4J_NS, "locationInfo",
                        "locationInfo");
              }

              if (properties) {
                //
                //    write MDC contents out as properties element
                //
                Set mdcKeySet = MDCKeySetExtractor.INSTANCE.getPropertyKeySet(event);

                if ((mdcKeySet != null) && (mdcKeySet.size() > 0)) {
                    attrs.clear();
                    transformer.startElement(LOG4J_NS,
                            "properties", "properties", attrs);
                    Object[] keys = mdcKeySet.toArray();
                    Arrays.sort(keys);
                    for (int i = 0; i < keys.length; i++) {
                        String key = keys[i].toString();
                        Object val = event.getMDC(key);
                        attrs.clear();
                        attrs.addAttribute(null, "name", "name", "CDATA", key);
                        attrs.addAttribute(null, "value", "value",
                                "CDATA", val.toString());
                        transformer.startElement(LOG4J_NS,
                                "data", "data", attrs);
                        transformer.endElement(LOG4J_NS, "data", "data");
                    }
                }
              }


            transformer.endElement(LOG4J_NS, "event", "event");
            transformer.endDocument();

            String body = encoding.decode(
                    ByteBuffer.wrap(outputStream.toByteArray())).toString();
            outputStream.reset();
            //
            //   must remove XML declaration since it may
            //      result in erroneous encoding info
            //      if written by FileAppender in a different encoding
            if (body.startsWith("<?xml ")) {
                int endDecl = body.indexOf("?>");
                if (endDecl != -1) {
                    for(endDecl += 2; 
					     endDecl < body.length() &&
						 (body.charAt(endDecl) == '\n' || body.charAt(endDecl) == '\r'); 
						 endDecl++);
                    return body.substring(endDecl);
                }
            }
            return body;
          } catch (Exception ex) {
              LogLog.error("Error during transformation", ex);
              return ex.toString();
          }
      }
      return "No valid transform or encoding specified.";
    }

    /**
     * Sets XSLT transform.
     * @param xsltdoc DOM document containing XSLT transform source,
     * may be modified.
     * @throws TransformerConfigurationException if transformer can not be
     * created.
     */
    public void setTransform(final Document xsltdoc)
            throws TransformerConfigurationException {
        //
        //  scan transform source for xsl:output elements
        //    and extract encoding, media (mime) type and output method
        //
        String encodingName = null;
        mediaType = null;
        String method = null;
        NodeList nodes = xsltdoc.getElementsByTagNameNS(
                XSLT_NS,
                "output");
        for(int i = 0; i < nodes.getLength(); i++) {
            Element outputElement = (Element) nodes.item(i);
            if (method == null || method.length() == 0) {
                method = outputElement.getAttributeNS(null, "method");
            }
            if (encodingName == null || encodingName.length() == 0) {
                encodingName = outputElement.getAttributeNS(null, "encoding");
            }
            if (mediaType == null || mediaType.length() == 0) {
                mediaType = outputElement.getAttributeNS(null, "media-type");
            }
        }

        if (mediaType == null || mediaType.length() == 0) {
            if ("html".equals(method)) {
                mediaType = "text/html";
            } else if ("xml".equals(method)) {
                mediaType = "text/xml";
            } else {
                mediaType = "text/plain";
            }
        }

        //
        //  if encoding was not specified,
        //     add xsl:output encoding=US-ASCII to XSLT source
        //
        if (encodingName == null || encodingName.length() == 0) {
            Element transformElement = xsltdoc.getDocumentElement();
            Element outputElement = xsltdoc.
                    createElementNS(XSLT_NS, "output");
            outputElement.setAttributeNS(null, "encoding", "US-ASCII");
            transformElement.insertBefore(outputElement, transformElement.getFirstChild());
            encoding = Charset.forName("US-ASCII");
        } else {
            encoding = Charset.forName(encodingName);
        }

        DOMSource transformSource = new DOMSource(xsltdoc);
        
        templates = transformerFactory.newTemplates(transformSource);

    }

    /**
     * {@inheritDoc}
     */
    public boolean parseUnrecognizedElement(final Element element,
                                            final Properties props)
            throws Exception {
        if (XSLT_NS.equals(element.getNamespaceURI()) ||
                element.getNodeName().indexOf("transform") != -1 ||
                element.getNodeName().indexOf("stylesheet") != -1) {
            //
            //   DOMConfigurator typically not namespace aware
            //     serialize tree and reparse.
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            DOMSource source = new DOMSource(element);
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
            transformer.transform(source, new StreamResult(os));

            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
            DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
            domFactory.setNamespaceAware(true);
            Document xsltdoc = domFactory.newDocumentBuilder().parse(is);
            setTransform(xsltdoc);
            return true;
        }
        return false;
    }


}
]]>
</codefragment>
</duplication>
<duplication lines="206" tokens="483">
<file line="35" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/extras/UtilLoggingLevel.java"/>
<file line="32" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/helpers/UtilLoggingLevel.java"/>
<codefragment>
<![CDATA[
public class UtilLoggingLevel extends Level {

    /**
     * Serialization version id.
     */
    private static final long serialVersionUID = 909301162611820211L;

    /**
     * Numerical value for SEVERE.
     */
    public static final int SEVERE_INT = 17000;
    /**
     * Numerical value for WARNING.
     */
    public static final int WARNING_INT = 16000;
    /**
     * Numerical value for INFO.
     */
    public static final int INFO_INT = 15000;
    /**
     * Numerical value for CONFIG.
     */
    public static final int CONFIG_INT = 14000;
    /**
     * Numerical value for FINE.
     */
    public static final int FINE_INT = 13000;
    /**
     * Numerical value for FINER.
     */
    public static final int FINER_INT = 12000;
    /**
     * Numerical value for FINEST.
     */
    public static final int FINEST_INT = 11000;
    /**
     * Numerical value for UNKNOWN.
     */
    public static final int UNKNOWN_INT = 10000;

    /**
     * SEVERE.
     */
    public static final UtilLoggingLevel SEVERE =
            new UtilLoggingLevel(SEVERE_INT, "SEVERE", 0);
    /**
     * WARNING.
     */
    public static final UtilLoggingLevel WARNING =
            new UtilLoggingLevel(WARNING_INT, "WARNING", 4);
    /**
     * INFO.
     */
    public static final UtilLoggingLevel INFO =
            new UtilLoggingLevel(INFO_INT, "INFO", 5);
    /**
     * CONFIG.
     */
    public static final UtilLoggingLevel CONFIG =
            new UtilLoggingLevel(CONFIG_INT, "CONFIG", 6);
    /**
     * FINE.
     */
    public static final UtilLoggingLevel FINE =
            new UtilLoggingLevel(FINE_INT, "FINE", 7);
    /**
     * FINER.
     */
    public static final UtilLoggingLevel FINER =
            new UtilLoggingLevel(FINER_INT, "FINER", 8);
    /**
     * FINEST.
     */
    public static final UtilLoggingLevel FINEST =
            new UtilLoggingLevel(FINEST_INT, "FINEST", 9);

    /**
     * Create new instance.
     * @param level numeric value for level.
     * @param levelStr symbolic name for level.
     * @param syslogEquivalent Equivalent syslog severity.
     */
    protected UtilLoggingLevel(final int level,
                               final String levelStr,
                               final int syslogEquivalent) {
        super(level, levelStr, syslogEquivalent);
    }

    /**
     * Convert an integer passed as argument to a level. If the
     * conversion fails, then this method returns the specified default.
     * @param val numeric value.
     * @param defaultLevel level to be returned if no level matches
     * numeric value.
     * @return matching level or default level.
     */
    public static UtilLoggingLevel toLevel(final int val,
                               final UtilLoggingLevel defaultLevel) {
        switch (val) {
            case SEVERE_INT:
                return SEVERE;

            case WARNING_INT:
                return WARNING;

            case INFO_INT:
                return INFO;

            case CONFIG_INT:
                return CONFIG;

            case FINE_INT:
                return FINE;

            case FINER_INT:
                return FINER;

            case FINEST_INT:
                return FINEST;

            default:
                return defaultLevel;
        }
    }

    /**
     * Gets level matching numeric value.
     * @param val numeric value.
     * @return  matching level or UtilLoggerLevel.FINEST if no match.
     */
    public static Level toLevel(final int val) {
        return toLevel(val, FINEST);
    }

    /**
     * Gets list of supported levels.
     * @return  list of supported levels.
     */
    public static List getAllPossibleLevels() {
        ArrayList list = new ArrayList();
        list.add(FINE);
        list.add(FINER);
        list.add(FINEST);
        list.add(INFO);
        list.add(CONFIG);
        list.add(WARNING);
        list.add(SEVERE);
        return list;
    }

    /**
     * Get level with specified symbolic name.
     * @param s symbolic name.
     * @return matching level or Level.DEBUG if no match.
     */
    public static Level toLevel(final String s) {
        return toLevel(s, Level.DEBUG);
    }


    /**
     * Get level with specified symbolic name.
     * @param sArg symbolic name.
     * @param defaultLevel level to return if no match.
     * @return matching level or defaultLevel if no match.
     */
    public static Level toLevel(final String sArg,
                                final Level defaultLevel) {
        if (sArg == null) {
            return defaultLevel;
        }

        String s = sArg.toUpperCase();

        if (s.equals("SEVERE")) {
            return SEVERE;
        }

        //if(s.equals("FINE")) return Level.FINE;
        if (s.equals("WARNING")) {
            return WARNING;
        }

        if (s.equals("INFO")) {
            return INFO;
        }

        if (s.equals("CONFI")) {
            return CONFIG;
        }

        if (s.equals("FINE")) {
            return FINE;
        }

        if (s.equals("FINER")) {
            return FINER;
        }

        if (s.equals("FINEST")) {
            return FINEST;
        }
        return defaultLevel;
    }

}
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="202">
<file line="101" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/AndRule.java"/>
<file line="101" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/OrRule.java"/>
<codefragment>
<![CDATA[
      if (result) {
          for (Iterator iter = tempMatches1.entrySet().iterator();iter.hasNext();) {
              Map.Entry entry = (Map.Entry)iter.next();
              Object key = entry.getKey();
              Set value = (Set)entry.getValue();
              Set mainSet = (Set) matches.get(key);
              if (mainSet == null) {
                  mainSet = new HashSet();
                  matches.put(key, mainSet);
              }
              mainSet.addAll(value);
          }
          for (Iterator iter = tempMatches2.entrySet().iterator();iter.hasNext();) {
              Map.Entry entry = (Map.Entry)iter.next();
              Object key = entry.getKey();
              Set value = (Set)entry.getValue();
              Set mainSet = (Set) matches.get(key);
              if (mainSet == null) {
                  mainSet = new HashSet();
                  matches.put(key, mainSet);
              }
              mainSet.addAll(value);
          }
      }
      return result;
  }
}
]]>
</codefragment>
</duplication>
<duplication lines="36" tokens="174">
<file line="61" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/LevelEqualsRule.java"/>
<file line="61" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/NotLevelEqualsRule.java"/>
<codefragment>
<![CDATA[
    private NotLevelEqualsRule(final Level level) {
        super();
        this.level = level;
    }

    /**
     * Populate list of levels.
     */
    private static void populateLevels() {
        levelList = new LinkedList();

        levelList.add(Level.FATAL.toString());
        levelList.add(Level.ERROR.toString());
        levelList.add(Level.WARN.toString());
        levelList.add(Level.INFO.toString());
        levelList.add(Level.DEBUG.toString());
		Level trace = Level.toLevel(5000, null);
		if (trace != null) {
			levelList.add(trace.toString());
	    }
    }

    /**
     * Create new rule.
     * @param value name of level.
     * @return instance of NotLevelEqualsRule.
     */
    public static Rule getRule(final String value) {
        Level thisLevel;
        if (levelList.contains(value.toUpperCase())) {
            thisLevel = Level.toLevel(value.toUpperCase());
          } else {
            thisLevel = UtilLoggingLevel.toLevel(value.toUpperCase());
        }

        return new NotLevelEqualsRule(thisLevel);
]]>
</codefragment>
</duplication>
<duplication lines="44" tokens="153">
<file line="106" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/LevelEqualsRule.java"/>
<file line="106" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/NotLevelEqualsRule.java"/>
<codefragment>
<![CDATA[
        boolean result = level.toInt() != eventLevel.toInt();
        if (result && matches != null) {
            Set entries = (Set) matches.get(LoggingEventFieldResolver.LEVEL_FIELD);
            if (entries == null) {
                entries = new HashSet();
                matches.put(LoggingEventFieldResolver.LEVEL_FIELD, entries);
            }
            entries.add(eventLevel);
        }
        return result;
    }

    /**
     * Deserialize the state of the object.
     *
     * @param in object input stream.
     *
     * @throws IOException if error in reading stream for deserialization.
     */
    private void readObject(final java.io.ObjectInputStream in)
            throws IOException {
        populateLevels();
        boolean isUtilLogging = in.readBoolean();
        int levelInt = in.readInt();
        if (isUtilLogging) {
            level = UtilLoggingLevel.toLevel(levelInt);
        } else {
            level = Level.toLevel(levelInt);
        }
    }

    /**
     * Serialize the state of the object.
     *
     * @param out object output stream.
     *
     * @throws IOException if error in writing stream during serialization.
     */
    private void writeObject(final java.io.ObjectOutputStream out)
            throws IOException {
        out.writeBoolean(level instanceof UtilLoggingLevel);
        out.writeInt(level.toInt());
    }
}
]]>
</codefragment>
</duplication>
<duplication lines="70" tokens="132">
<file line="47" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/extras/SoundAppender.java"/>
<file line="44" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/varia/SoundAppender.java"/>
<codefragment>
<![CDATA[
public final class SoundAppender extends AppenderSkeleton {

	private AudioClip clip;
	private String audioURL;

	public SoundAppender() {
	}

	/**
	 * Attempt to initialize the appender by creating a reference to an AudioClip.
	 * 
	 * Will log a message if format is not supported, file not found, etc.
	 * 
	 */
	public void activateOptions() {
		/*
		 * AudioSystem.getAudioInputStream requires jdk 1.3,
		 * so we use applet.newaudioclip instead
		 *
		 */
		try {
			clip = Applet.newAudioClip(new URL(audioURL));
		} catch (MalformedURLException mue) {
            LogLog.error("unable to initialize SoundAppender", mue);}
		if (clip == null) {
		      LogLog.error("Unable to initialize SoundAppender");
		}
	}

	/**
	 * Accessor
	 * 
	 * @return audio file
	 */
	public String getAudioURL() {
		return audioURL;
	}

	/**
	 * Mutator - common format for a file-based url:
	 * file:///c:/path/someaudioclip.wav
	 * 
	 * @param audioURL
	 */
	public void setAudioURL(String audioURL) {
		this.audioURL = audioURL;
	}

	/**
	 * Play the sound if an event is being processed
	 */
	protected void append(LoggingEvent event) {
		if (clip != null) {
			clip.play();
		}
	}

	public void close() {
		//nothing to do
	}

    /**
     * Gets whether appender requires a layout.
     * @return false
     */
  public boolean requiresLayout() {
      return false;
  }

}
]]>
</codefragment>
</duplication>
<duplication lines="40" tokens="121">
<file line="60" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rolling/helper/GZCompressAction.java"/>
<file line="61" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rolling/helper/ZipCompressAction.java"/>
<codefragment>
<![CDATA[
  public ZipCompressAction(
    final File source, final File destination, final boolean deleteSource) {
    if (source == null) {
      throw new NullPointerException("source");
    }

    if (destination == null) {
      throw new NullPointerException("destination");
    }

    this.source = source;
    this.destination = destination;
    this.deleteSource = deleteSource;
  }

  /**
   * Compress.
   * @return true if successfully compressed.
   * @throws IOException on IO exception.
   */
  public boolean execute() throws IOException {
    return execute(source, destination, deleteSource);
  }

  /**
   * Compress a file.
   *
   * @param source file to compress, may not be null.
   * @param destination compressed file, may not be null.
   * @param deleteSource if true, attempt to delete file on completion.  Failure to delete
   * does not cause an exception to be thrown or affect return value.
   * @return true if source file compressed.
   * @throws IOException on IO exception.
   */
  public static boolean execute(
    final File source, final File destination, final boolean deleteSource)
          throws IOException {
    if (source.exists()) {
      FileInputStream fis = new FileInputStream(source);
      FileOutputStream fos = new FileOutputStream(destination);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="108">
<file line="245" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rolling/RollingFileAppender.java"/>
<file line="292" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rolling/RollingFileAppender.java"/>
<codefragment>
<![CDATA[
              this.qw = createQuietWriter(newWriter);

              boolean success = true;

              if (rollover.getSynchronous() != null) {
                success = false;

                try {
                  success = rollover.getSynchronous().execute();
                } catch (Exception ex) {
                  exception = ex;
                }
              }

              if (success) {
                if (rollover.getAppend()) {
                  fileLength = new File(rollover.getActiveFileName()).length();
                } else {
                  fileLength = 0;
                }

                if (rollover.getAsynchronous() != null) {
                  lastRolloverAsyncAction = rollover.getAsynchronous();
                  new Thread(lastRolloverAsyncAction).start();
                }
]]>
</codefragment>
</duplication>
<duplication lines="17" tokens="103">
<file line="64" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/LevelEqualsRule.java"/>
<file line="57" path="/home/curta/trunk/target/checkout/src/main/java/org/apache/log4j/rule/LevelInequalityRule.java"/>
<codefragment>
<![CDATA[
    }

    /**
     * Populate list of levels.
     */
    private static void populateLevels() {
        levelList = new LinkedList();

        levelList.add(Level.FATAL.toString());
        levelList.add(Level.ERROR.toString());
        levelList.add(Level.WARN.toString());
        levelList.add(Level.INFO.toString());
        levelList.add(Level.DEBUG.toString());
		Level trace = Level.toLevel(5000, null);
		if (trace != null) {
			levelList.add(trace.toString());
		}
]]>
</codefragment>
</duplication>
</pmd-cpd>