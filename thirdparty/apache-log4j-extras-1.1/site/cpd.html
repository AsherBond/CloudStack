<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

-->
<!-- Generated by Apache Maven Doxia at Nov 15, 2010 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Extras - CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
      </head>
  <body class="composite">
    <div id="banner">
                  <a href="http://logging.apache.org/" id="bannerLeft">
                                                <img src="images/ls-logo.jpg" alt="Logging Services" />
                </a>
                        <a href="http://logging.apache.org/log4j" id="bannerRight">
                                                <img src="images/logo.jpg" alt="Apache log4j" />
                </a>
            <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2010-11-15</span>
                  &nbsp;| <span id="projectVersion">Version: 1.1</span>
                          |                           <a href="http://www.apache.org/" class="externalLink" title="Apache">Apache</a>
                &gt;
                              <a href="http://logging.apache.org/" class="externalLink" title="Logging Services">Logging Services</a>
                &gt;
                              <a href="http://logging.apache.org/log4j/" class="externalLink" title="log4j">log4j</a>
                &gt;
                              <a href="http://logging.apache.org/log4j/companions/" class="externalLink" title="Companions">Companions</a>
                &gt;
                              <a href="http://logging.apache.org:80/log4j/companions/extras/" class="externalLink" title="extras">extras</a>
                          </div>
            <div class="xright">        
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                <h5>Get extras</h5>
                  <ul>
                  <li class="none">
                          <a href="download.html" title="Download">Download</a>
            </li>
                  <li class="none">
                          <a href="changes-report.html" title="Changes">Changes</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/licenses/" class="externalLink" title="License">License</a>
            </li>
          </ul>
                       <h5>About extras</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="What is it?">What is it?</a>
            </li>
                  <li class="none">
                          <a href="roadmap.html" title="Roadmap">Roadmap</a>
            </li>
                  <li class="none">
                          <a href="apidocs/index.html" title="JavaDoc">JavaDoc</a>
            </li>
          </ul>
                       <h5>Community</h5>
                  <ul>
                  <li class="none">
                          <a href="mail-lists.html" title="Mailing Lists">Mailing Lists</a>
            </li>
                  <li class="none">
                          <a href="issue-tracking.html" title="Issue Tracking">Issue Tracking</a>
            </li>
          </ul>
                       <h5>Development</h5>
                  <ul>
                  <li class="none">
                          <a href="source-repository.html" title="Repository">Repository</a>
            </li>
                  <li class="none">
                          <a href="jxr.html" title="Cross Reference">Cross Reference</a>
            </li>
                  <li class="none">
                          <a href="dependencies.html" title="Dependencies">Dependencies</a>
            </li>
                  <li class="none">
                          <a href="integration.html" title="Continuous Integration">Continuous Integration</a>
            </li>
                  <li class="none">
            <strong>Duplication</strong>
          </li>
                  <li class="none">
                          <a href="pmd.html" title="PMD">PMD</a>
            </li>
          </ul>
                       <h5>Apache</h5>
                  <ul>
                  <li class="none">
                          <a href="http://www.apache.org" class="externalLink" title="Home">Home</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/foundation/sponsorship.html" class="externalLink" title="Sponsorship">Sponsorship</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/foundation/thanks.html" class="externalLink" title="Thanks">Thanks</a>
            </li>
                  <li class="none">
                          <a href="http://www.apache.org/security/" class="externalLink" title="Security">Security</a>
            </li>
                  <li class="none">
                          <a href="http://www.apachecon.com" class="externalLink" title="Conferences">Conferences</a>
            </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>CPD Results</h2>
<p>The following document contains the results of PMD's  <a href="http://pmd.sourceforge.net/cpd.html" class="externalLink">CPD</a> 4.2.5.</p>
</div>
<div class="section"><h2>Duplications</h2>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/LogMF.java</td>
<td><a href="./xref/org/apache/log4j/LogMF.html#270">270</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/LogSF.java</td>
<td><a href="./xref/org/apache/log4j/LogSF.html#135">135</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>    private static final String FQCN = LogSF.class.getName();

    /**
     * Equivalent of Logger.forcedLog.
     *
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param msg message, may be null.
     */
    private static void forcedLog(final Logger logger,
                                  final Level level,
                                  final String msg) {
        logger.callAppenders(new LoggingEvent(FQCN, logger, level, msg, null));
    }

    /**
     * Equivalent of Logger.forcedLog.
     *
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param msg message, may be null.
     * @param t throwable.
     */
    private static void forcedLog(final Logger logger,
                                  final Level level,
                                  final String msg,
                                  final Throwable t) {
        logger.callAppenders(new LoggingEvent(FQCN, logger, level, msg, t));
    }
    /**
         * Log a parameterized message at trace level.
         * @param logger logger, may not be null.
         * @param pattern pattern, may be null.
         * @param arguments an array of arguments to be
         *          formatted and substituted.
         */
    public static void trace(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at error level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void error(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.ERROR)) {
            forcedLog(logger, Level.ERROR, format(pattern, arguments));
        }
    }

    /**
     * Log a parameterized message at fatal level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void fatal(final Logger logger, final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.FATAL)) {
            forcedLog(logger, Level.FATAL, format(pattern, arguments));
        }
    }

    /**
         * Log a parameterized message at trace level.
         * @param logger logger, may not be null.
         * @param t throwable, may be null.
         * @param pattern pattern, may be null.
         * @param arguments an array of arguments to be
         *          formatted and substituted.
         */
    public static void trace(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void debug(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void info(final Logger logger,
                            final Throwable t,
                            final String pattern,
        final Object[] arguments) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void warn(final Logger logger,
                            final Throwable t,
                            final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at error level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void error(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.ERROR)) {
            forcedLog(logger, Level.ERROR, format(pattern, arguments), t);
        }
    }

    /**
     * Log a parameterized message at fatal level.
     * @param logger logger, may not be null.
     * @param t throwable, may be null.
     * @param pattern pattern, may be null.
     * @param arguments an array of arguments to be formatted and substituted.
     */
    public static void fatal(final Logger logger,
                             final Throwable t,
                             final String pattern,
        final Object[] arguments) {
        if (logger.isEnabledFor(Level.FATAL)) {
            forcedLog(logger, Level.FATAL, format(pattern, arguments), t);
        }
    }



    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at trace level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void trace(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isEnabledFor(TRACE)) {
            forcedLog(logger, TRACE,
                    format(pattern, toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at debug level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void debug(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isDebugEnabled()) {
            forcedLog(logger, Level.DEBUG,
                    format(pattern, toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern,
                    toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at info level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void info(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isInfoEnabled()) {
            forcedLog(logger, Level.INFO, format(pattern,
                    toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final boolean argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final char argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final byte argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final short argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final int argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final long argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final float argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final double argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, valueOf(argument)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param argument a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object argument) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern, argument));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at warn level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void warn(final Logger logger, final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isEnabledFor(Level.WARN)) {
            forcedLog(logger, Level.WARN, format(pattern,
                    toArray(arg0, arg1, arg2, arg3)));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param parameters parameters to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, parameters));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
     * @param t throwable, may be null.
      * @param pattern pattern, may be null.
     * @param parameters parameters to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final Throwable t,
                             final String pattern,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, parameters), t);
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final Object param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(param1)));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final boolean param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final byte param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final char param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final short param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final int param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final long param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final float param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message at specified level.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param pattern pattern, may be null.
     * @param param1 parameter to the log message.
      */
    public static void log(final Logger logger,
                             final Level level,
                             final String pattern,
                             final double param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(valueOf(param1))));
        }
    }


    /**
     * Log a parameterized message at specified level.
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     */
    public static void log(final Logger logger,
                            final Level level,
                            final String pattern,
        final Object arg0, final Object arg1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(arg0, arg1)));
        }
    }

    /**
     * Log a parameterized message at specifed level.
     * @param logger logger, may not be null.
     * @param level level, may not be null.
     * @param pattern pattern, may be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     */
    public static void log(final Logger logger,
                           final Level level,
                           final String pattern,
        final Object arg0, final Object arg1, final Object arg2) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(pattern, toArray(arg0, arg1, arg2)));
        }
    }

    /**
     * Log a parameterized message at specified level.
     * @param logger logger, may not be null.
     * @param pattern pattern, may be null.
     * @param level level, may not be null.
     * @param arg0 a value to be formatted and substituted.
     * @param arg1 a value to be formatted and substituted.
     * @param arg2 a value to be formatted and substituted.
     * @param arg3 a value to be formatted and substituted.
     */
    public static void log(final Logger logger,
                           final Level level,
                           final String pattern,
        final Object arg0, final Object arg1, final Object arg2,
        final Object arg3) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level, format(pattern,
                    toArray(arg0, arg1, arg2, arg3)));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param parameters parameters to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, parameters));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
     * @param t throwable, may be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param parameters parameters to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final Throwable t,
                             final String bundleName,
                             final String key,
                             final Object[] parameters) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, parameters), t);
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(param1)));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final boolean param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final char param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final byte param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final short param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final int param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final long param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }
    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final float param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final double param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(valueOf(param1))));
        }
    }

    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param0 Parameter to the log message.
     * @param param1 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param0,
                             final Object param1) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(param0, param1)));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param0 Parameter to the log message.
     * @param param1 Parameter to the log message.
     * @param param2 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param0,
                             final Object param1,
                             final Object param2) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key, toArray(param0, param1, param2)));
        }
    }


    /**
      * Log a parameterized message using a pattern from a resource bundle.
      * @param logger logger, may not be null.
      * @param level level, may not be null.
      * @param bundleName resource bundle name, may be null.
     * @param key key, may be null.
     * @param param0 Parameter to the log message.
     * @param param1 Parameter to the log message.
     * @param param2 Parameter to the log message.
     * @param param3 Parameter to the log message.
      */
    public static void logrb(final Logger logger,
                             final Level level,
                             final String bundleName,
                             final String key,
                             final Object param0,
                             final Object param1,
                             final Object param2,
                             final Object param3) {
        if (logger.isEnabledFor(level)) {
            forcedLog(logger, level,
                    format(bundleName, key,
                            toArray(param0, param1, param2, param3)));
        }
    }
}</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/extras/XSLTLayout.java</td>
<td><a href="./xref/org/apache/log4j/extras/XSLTLayout.html#100">100</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/xml/XSLTLayout.java</td>
<td><a href="./xref/org/apache/log4j/xml/XSLTLayout.html#96">96</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>        implements UnrecognizedElementHandler {
    /**
     * Namespace for XSLT.
     */
    private static final String XSLT_NS = &quot;http://www.w3.org/1999/XSL/Transform&quot;;
    /**
     * Namespace for log4j events.
     */
    private static final String LOG4J_NS = &quot;http://jakarta.apache.org/log4j/&quot;;
    /**
     * Whether location information should be written.
     */
    private boolean locationInfo = false;
    /**
     * media-type (mime type) extracted from XSLT transform.
     */
    private String mediaType = &quot;text/plain&quot;;
    /**
     * Encoding extracted from XSLT transform.
     */
    private Charset encoding;
    /**
     * Transformer factory.
     */
    private SAXTransformerFactory transformerFactory;
    /**
     * XSLT templates.
     */
    private Templates templates;
    /**
     * Output stream.
     */
    private final ByteArrayOutputStream outputStream;
    /**
     * Whether throwable information should be ignored.
     */
    private boolean ignoresThrowable = false;
    /**
     * Whether properties should be extracted.
     */
    private boolean properties = true;
    /**
     * Whether activateOptions has been called.
     */
    private boolean activated = false;

    /**
     * DateFormat for UTC time.
     */
    private final CachedDateFormat utcDateFormat;

    /**
     * Default constructor.
     *
     */
    public XSLTLayout() {
        outputStream = new ByteArrayOutputStream();
        transformerFactory = (SAXTransformerFactory)
                TransformerFactory.newInstance();

        SimpleDateFormat zdf = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;);
        zdf.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));
        utcDateFormat = new CachedDateFormat(zdf, 1000);
    }

    /**
     * {@inheritDoc}
     */
    public synchronized String getContentType() {
        return mediaType;
    }

    /**
     * The &lt;b&gt;LocationInfo &lt;/b&gt; option takes a boolean value. By default, it is
     * set to false which means there will be no location information output by
     * this layout. If the the option is set to true, then the file name and line
     * number of the statement at the origin of the log statement will be output.
     *
     * &lt;p&gt;
     * If you are embedding this layout within an {@link
     * org.apache.log4j.net.SMTPAppender} then make sure to set the
     * &lt;b&gt;LocationInfo &lt;/b&gt; option of that appender as well.
     *
     * @param flag new value.
     */
    public synchronized void setLocationInfo(final boolean flag) {
      locationInfo = flag;
    }

    /**
     * Gets whether location info should be output.
     * @return if location is output.
     */
    public synchronized boolean getLocationInfo() {
      return locationInfo;
    }

    /**
     * Sets whether MDC key-value pairs should be output, default false.
     * @param flag new value.
     */
    public synchronized void setProperties(final boolean flag) {
      properties = flag;
    }

    /**
     * Gets whether MDC key-value pairs should be output.
     * @return true if MDC key-value pairs are output.
     */
    public synchronized boolean getProperties() {
      return properties;
    }


    /** {@inheritDoc} */
    public synchronized void activateOptions() {
        if (templates == null) {
            try {
                InputStream is = XSLTLayout.class.getResourceAsStream(&quot;default.xslt&quot;);
                StreamSource ss = new StreamSource(is);
                templates = transformerFactory.newTemplates(ss);
                encoding = Charset.forName(&quot;US-ASCII&quot;);
                mediaType = &quot;text/plain&quot;;
            } catch (Exception ex) {
                LogLog.error(&quot;Error loading default.xslt&quot;, ex);
            }
        }
        activated = true;
    }

    /**
     * Gets whether throwables should not be output.
     * @return true if throwables should not be output.
     */
    public synchronized boolean ignoresThrowable() {
        return ignoresThrowable;
    }

    /**
     * Sets whether throwables should not be output.
     * @param ignoresThrowable if true, throwables should not be output.
    */
    public synchronized void setIgnoresThrowable(boolean ignoresThrowable) {
      this.ignoresThrowable = ignoresThrowable;
    }



    /**
     * {@inheritDoc}
     */
    public synchronized String format(final LoggingEvent event) {
      if (!activated) {
          activateOptions();
      }
      if (templates != null &amp;&amp; encoding != null) {
          outputStream.reset();

          try {
            TransformerHandler transformer =
                      transformerFactory.newTransformerHandler(templates);

            transformer.setResult(new StreamResult(outputStream));
            transformer.startDocument();

            //
            //   event element
            //
            AttributesImpl attrs = new AttributesImpl();
            attrs.addAttribute(null, &quot;logger&quot;, &quot;logger&quot;,
                    &quot;CDATA&quot;, event.getLoggerName());
            attrs.addAttribute(null, &quot;timestamp&quot;, &quot;timestamp&quot;,
                    &quot;CDATA&quot;, Long.toString(event.timeStamp));
            attrs.addAttribute(null, &quot;level&quot;, &quot;level&quot;,
                    &quot;CDATA&quot;, event.getLevel().toString());
            attrs.addAttribute(null, &quot;thread&quot;, &quot;thread&quot;,
                    &quot;CDATA&quot;, event.getThreadName());
            StringBuffer buf = new StringBuffer();
            utcDateFormat.format(event.timeStamp, buf);
            attrs.addAttribute(null, &quot;time&quot;, &quot;time&quot;, &quot;CDATA&quot;, buf.toString());


            transformer.startElement(LOG4J_NS, &quot;event&quot;, &quot;event&quot;, attrs);
            attrs.clear();

            //
            //   message element
            //
            transformer.startElement(LOG4J_NS, &quot;message&quot;, &quot;message&quot;, attrs);
            String msg = event.getRenderedMessage();
            if (msg != null &amp;&amp; msg.length() &gt; 0) {
                transformer.characters(msg.toCharArray(), 0, msg.length());
            }
            transformer.endElement(LOG4J_NS, &quot;message&quot;, &quot;message&quot;);

            //
            //    NDC element
            //
            String ndc = event.getNDC();
            if (ndc != null) {
                transformer.startElement(LOG4J_NS, &quot;NDC&quot;, &quot;NDC&quot;, attrs);
                char[] ndcChars = ndc.toCharArray();
                transformer.characters(ndcChars, 0, ndcChars.length);
                transformer.endElement(LOG4J_NS, &quot;NDC&quot;, &quot;NDC&quot;);
            }

            //
            //    throwable element unless suppressed
            //
              if (!ignoresThrowable) {
                String[] s = event.getThrowableStrRep();
                if (s != null) {
                    transformer.startElement(LOG4J_NS, &quot;throwable&quot;,
                            &quot;throwable&quot;, attrs);
                    char[] nl = new char[] { '\n' };
                    for (int i = 0; i &lt; s.length; i++) {
                        char[] line = s[i].toCharArray();
                        transformer.characters(line, 0, line.length);
                        transformer.characters(nl, 0, nl.length);
                    }
                    transformer.endElement(LOG4J_NS, &quot;throwable&quot;, &quot;throwable&quot;);
                }
              }

              //
              //     location info unless suppressed
              //
              //
              if (locationInfo) {
                LocationInfo locationInfo = event.getLocationInformation();
                attrs.addAttribute(null, &quot;class&quot;, &quot;class&quot;, &quot;CDATA&quot;,
                        locationInfo.getClassName());
                attrs.addAttribute(null, &quot;method&quot;, &quot;method&quot;, &quot;CDATA&quot;,
                          locationInfo.getMethodName());
                attrs.addAttribute(null, &quot;file&quot;, &quot;file&quot;, &quot;CDATA&quot;,
                            locationInfo.getFileName());
                attrs.addAttribute(null, &quot;line&quot;, &quot;line&quot;, &quot;CDATA&quot;,
                            locationInfo.getLineNumber());
                transformer.startElement(LOG4J_NS, &quot;locationInfo&quot;,
                        &quot;locationInfo&quot;, attrs);
                transformer.endElement(LOG4J_NS, &quot;locationInfo&quot;,
                        &quot;locationInfo&quot;);
              }

              if (properties) {
                //
                //    write MDC contents out as properties element
                //
                Set mdcKeySet = MDCKeySetExtractor.INSTANCE.getPropertyKeySet(event);

                if ((mdcKeySet != null) &amp;&amp; (mdcKeySet.size() &gt; 0)) {
                    attrs.clear();
                    transformer.startElement(LOG4J_NS,
                            &quot;properties&quot;, &quot;properties&quot;, attrs);
                    Object[] keys = mdcKeySet.toArray();
                    Arrays.sort(keys);
                    for (int i = 0; i &lt; keys.length; i++) {
                        String key = keys[i].toString();
                        Object val = event.getMDC(key);
                        attrs.clear();
                        attrs.addAttribute(null, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;, key);
                        attrs.addAttribute(null, &quot;value&quot;, &quot;value&quot;,
                                &quot;CDATA&quot;, val.toString());
                        transformer.startElement(LOG4J_NS,
                                &quot;data&quot;, &quot;data&quot;, attrs);
                        transformer.endElement(LOG4J_NS, &quot;data&quot;, &quot;data&quot;);
                    }
                }
              }


            transformer.endElement(LOG4J_NS, &quot;event&quot;, &quot;event&quot;);
            transformer.endDocument();

            String body = encoding.decode(
                    ByteBuffer.wrap(outputStream.toByteArray())).toString();
            outputStream.reset();
            //
            //   must remove XML declaration since it may
            //      result in erroneous encoding info
            //      if written by FileAppender in a different encoding
            if (body.startsWith(&quot;&lt;?xml &quot;)) {
                int endDecl = body.indexOf(&quot;?&gt;&quot;);
                if (endDecl != -1) {
                    for(endDecl += 2; 
					     endDecl &lt; body.length() &amp;&amp;
						 (body.charAt(endDecl) == '\n' || body.charAt(endDecl) == '\r'); 
						 endDecl++);
                    return body.substring(endDecl);
                }
            }
            return body;
          } catch (Exception ex) {
              LogLog.error(&quot;Error during transformation&quot;, ex);
              return ex.toString();
          }
      }
      return &quot;No valid transform or encoding specified.&quot;;
    }

    /**
     * Sets XSLT transform.
     * @param xsltdoc DOM document containing XSLT transform source,
     * may be modified.
     * @throws TransformerConfigurationException if transformer can not be
     * created.
     */
    public void setTransform(final Document xsltdoc)
            throws TransformerConfigurationException {
        //
        //  scan transform source for xsl:output elements
        //    and extract encoding, media (mime) type and output method
        //
        String encodingName = null;
        mediaType = null;
        String method = null;
        NodeList nodes = xsltdoc.getElementsByTagNameNS(
                XSLT_NS,
                &quot;output&quot;);
        for(int i = 0; i &lt; nodes.getLength(); i++) {
            Element outputElement = (Element) nodes.item(i);
            if (method == null || method.length() == 0) {
                method = outputElement.getAttributeNS(null, &quot;method&quot;);
            }
            if (encodingName == null || encodingName.length() == 0) {
                encodingName = outputElement.getAttributeNS(null, &quot;encoding&quot;);
            }
            if (mediaType == null || mediaType.length() == 0) {
                mediaType = outputElement.getAttributeNS(null, &quot;media-type&quot;);
            }
        }

        if (mediaType == null || mediaType.length() == 0) {
            if (&quot;html&quot;.equals(method)) {
                mediaType = &quot;text/html&quot;;
            } else if (&quot;xml&quot;.equals(method)) {
                mediaType = &quot;text/xml&quot;;
            } else {
                mediaType = &quot;text/plain&quot;;
            }
        }

        //
        //  if encoding was not specified,
        //     add xsl:output encoding=US-ASCII to XSLT source
        //
        if (encodingName == null || encodingName.length() == 0) {
            Element transformElement = xsltdoc.getDocumentElement();
            Element outputElement = xsltdoc.
                    createElementNS(XSLT_NS, &quot;output&quot;);
            outputElement.setAttributeNS(null, &quot;encoding&quot;, &quot;US-ASCII&quot;);
            transformElement.insertBefore(outputElement, transformElement.getFirstChild());
            encoding = Charset.forName(&quot;US-ASCII&quot;);
        } else {
            encoding = Charset.forName(encodingName);
        }

        DOMSource transformSource = new DOMSource(xsltdoc);
        
        templates = transformerFactory.newTemplates(transformSource);

    }

    /**
     * {@inheritDoc}
     */
    public boolean parseUnrecognizedElement(final Element element,
                                            final Properties props)
            throws Exception {
        if (XSLT_NS.equals(element.getNamespaceURI()) ||
                element.getNodeName().indexOf(&quot;transform&quot;) != -1 ||
                element.getNodeName().indexOf(&quot;stylesheet&quot;) != -1) {
            //
            //   DOMConfigurator typically not namespace aware
            //     serialize tree and reparse.
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            DOMSource source = new DOMSource(element);
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
            transformer.transform(source, new StreamResult(os));

            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
            DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
            domFactory.setNamespaceAware(true);
            Document xsltdoc = domFactory.newDocumentBuilder().parse(is);
            setTransform(xsltdoc);
            return true;
        }
        return false;
    }


}</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/extras/UtilLoggingLevel.java</td>
<td><a href="./xref/org/apache/log4j/extras/UtilLoggingLevel.html#35">35</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/helpers/UtilLoggingLevel.java</td>
<td><a href="./xref/org/apache/log4j/helpers/UtilLoggingLevel.html#32">32</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>public class UtilLoggingLevel extends Level {

    /**
     * Serialization version id.
     */
    private static final long serialVersionUID = 909301162611820211L;

    /**
     * Numerical value for SEVERE.
     */
    public static final int SEVERE_INT = 17000;
    /**
     * Numerical value for WARNING.
     */
    public static final int WARNING_INT = 16000;
    /**
     * Numerical value for INFO.
     */
    public static final int INFO_INT = 15000;
    /**
     * Numerical value for CONFIG.
     */
    public static final int CONFIG_INT = 14000;
    /**
     * Numerical value for FINE.
     */
    public static final int FINE_INT = 13000;
    /**
     * Numerical value for FINER.
     */
    public static final int FINER_INT = 12000;
    /**
     * Numerical value for FINEST.
     */
    public static final int FINEST_INT = 11000;
    /**
     * Numerical value for UNKNOWN.
     */
    public static final int UNKNOWN_INT = 10000;

    /**
     * SEVERE.
     */
    public static final UtilLoggingLevel SEVERE =
            new UtilLoggingLevel(SEVERE_INT, &quot;SEVERE&quot;, 0);
    /**
     * WARNING.
     */
    public static final UtilLoggingLevel WARNING =
            new UtilLoggingLevel(WARNING_INT, &quot;WARNING&quot;, 4);
    /**
     * INFO.
     */
    public static final UtilLoggingLevel INFO =
            new UtilLoggingLevel(INFO_INT, &quot;INFO&quot;, 5);
    /**
     * CONFIG.
     */
    public static final UtilLoggingLevel CONFIG =
            new UtilLoggingLevel(CONFIG_INT, &quot;CONFIG&quot;, 6);
    /**
     * FINE.
     */
    public static final UtilLoggingLevel FINE =
            new UtilLoggingLevel(FINE_INT, &quot;FINE&quot;, 7);
    /**
     * FINER.
     */
    public static final UtilLoggingLevel FINER =
            new UtilLoggingLevel(FINER_INT, &quot;FINER&quot;, 8);
    /**
     * FINEST.
     */
    public static final UtilLoggingLevel FINEST =
            new UtilLoggingLevel(FINEST_INT, &quot;FINEST&quot;, 9);

    /**
     * Create new instance.
     * @param level numeric value for level.
     * @param levelStr symbolic name for level.
     * @param syslogEquivalent Equivalent syslog severity.
     */
    protected UtilLoggingLevel(final int level,
                               final String levelStr,
                               final int syslogEquivalent) {
        super(level, levelStr, syslogEquivalent);
    }

    /**
     * Convert an integer passed as argument to a level. If the
     * conversion fails, then this method returns the specified default.
     * @param val numeric value.
     * @param defaultLevel level to be returned if no level matches
     * numeric value.
     * @return matching level or default level.
     */
    public static UtilLoggingLevel toLevel(final int val,
                               final UtilLoggingLevel defaultLevel) {
        switch (val) {
            case SEVERE_INT:
                return SEVERE;

            case WARNING_INT:
                return WARNING;

            case INFO_INT:
                return INFO;

            case CONFIG_INT:
                return CONFIG;

            case FINE_INT:
                return FINE;

            case FINER_INT:
                return FINER;

            case FINEST_INT:
                return FINEST;

            default:
                return defaultLevel;
        }
    }

    /**
     * Gets level matching numeric value.
     * @param val numeric value.
     * @return  matching level or UtilLoggerLevel.FINEST if no match.
     */
    public static Level toLevel(final int val) {
        return toLevel(val, FINEST);
    }

    /**
     * Gets list of supported levels.
     * @return  list of supported levels.
     */
    public static List getAllPossibleLevels() {
        ArrayList list = new ArrayList();
        list.add(FINE);
        list.add(FINER);
        list.add(FINEST);
        list.add(INFO);
        list.add(CONFIG);
        list.add(WARNING);
        list.add(SEVERE);
        return list;
    }

    /**
     * Get level with specified symbolic name.
     * @param s symbolic name.
     * @return matching level or Level.DEBUG if no match.
     */
    public static Level toLevel(final String s) {
        return toLevel(s, Level.DEBUG);
    }


    /**
     * Get level with specified symbolic name.
     * @param sArg symbolic name.
     * @param defaultLevel level to return if no match.
     * @return matching level or defaultLevel if no match.
     */
    public static Level toLevel(final String sArg,
                                final Level defaultLevel) {
        if (sArg == null) {
            return defaultLevel;
        }

        String s = sArg.toUpperCase();

        if (s.equals(&quot;SEVERE&quot;)) {
            return SEVERE;
        }

        //if(s.equals(&quot;FINE&quot;)) return Level.FINE;
        if (s.equals(&quot;WARNING&quot;)) {
            return WARNING;
        }

        if (s.equals(&quot;INFO&quot;)) {
            return INFO;
        }

        if (s.equals(&quot;CONFI&quot;)) {
            return CONFIG;
        }

        if (s.equals(&quot;FINE&quot;)) {
            return FINE;
        }

        if (s.equals(&quot;FINER&quot;)) {
            return FINER;
        }

        if (s.equals(&quot;FINEST&quot;)) {
            return FINEST;
        }
        return defaultLevel;
    }

}</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/rule/AndRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/AndRule.html#101">101</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/rule/OrRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/OrRule.html#101">101</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>      if (result) {
          for (Iterator iter = tempMatches1.entrySet().iterator();iter.hasNext();) {
              Map.Entry entry = (Map.Entry)iter.next();
              Object key = entry.getKey();
              Set value = (Set)entry.getValue();
              Set mainSet = (Set) matches.get(key);
              if (mainSet == null) {
                  mainSet = new HashSet();
                  matches.put(key, mainSet);
              }
              mainSet.addAll(value);
          }
          for (Iterator iter = tempMatches2.entrySet().iterator();iter.hasNext();) {
              Map.Entry entry = (Map.Entry)iter.next();
              Object key = entry.getKey();
              Set value = (Set)entry.getValue();
              Set mainSet = (Set) matches.get(key);
              if (mainSet == null) {
                  mainSet = new HashSet();
                  matches.put(key, mainSet);
              }
              mainSet.addAll(value);
          }
      }
      return result;
  }
}</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/rule/LevelEqualsRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/LevelEqualsRule.html#61">61</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/rule/NotLevelEqualsRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/NotLevelEqualsRule.html#61">61</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>    private NotLevelEqualsRule(final Level level) {
        super();
        this.level = level;
    }

    /**
     * Populate list of levels.
     */
    private static void populateLevels() {
        levelList = new LinkedList();

        levelList.add(Level.FATAL.toString());
        levelList.add(Level.ERROR.toString());
        levelList.add(Level.WARN.toString());
        levelList.add(Level.INFO.toString());
        levelList.add(Level.DEBUG.toString());
		Level trace = Level.toLevel(5000, null);
		if (trace != null) {
			levelList.add(trace.toString());
	    }
    }

    /**
     * Create new rule.
     * @param value name of level.
     * @return instance of NotLevelEqualsRule.
     */
    public static Rule getRule(final String value) {
        Level thisLevel;
        if (levelList.contains(value.toUpperCase())) {
            thisLevel = Level.toLevel(value.toUpperCase());
          } else {
            thisLevel = UtilLoggingLevel.toLevel(value.toUpperCase());
        }

        return new NotLevelEqualsRule(thisLevel);</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/rule/LevelEqualsRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/LevelEqualsRule.html#106">106</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/rule/NotLevelEqualsRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/NotLevelEqualsRule.html#106">106</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>        boolean result = level.toInt() != eventLevel.toInt();
        if (result &amp;&amp; matches != null) {
            Set entries = (Set) matches.get(LoggingEventFieldResolver.LEVEL_FIELD);
            if (entries == null) {
                entries = new HashSet();
                matches.put(LoggingEventFieldResolver.LEVEL_FIELD, entries);
            }
            entries.add(eventLevel);
        }
        return result;
    }

    /**
     * Deserialize the state of the object.
     *
     * @param in object input stream.
     *
     * @throws IOException if error in reading stream for deserialization.
     */
    private void readObject(final java.io.ObjectInputStream in)
            throws IOException {
        populateLevels();
        boolean isUtilLogging = in.readBoolean();
        int levelInt = in.readInt();
        if (isUtilLogging) {
            level = UtilLoggingLevel.toLevel(levelInt);
        } else {
            level = Level.toLevel(levelInt);
        }
    }

    /**
     * Serialize the state of the object.
     *
     * @param out object output stream.
     *
     * @throws IOException if error in writing stream during serialization.
     */
    private void writeObject(final java.io.ObjectOutputStream out)
            throws IOException {
        out.writeBoolean(level instanceof UtilLoggingLevel);
        out.writeInt(level.toInt());
    }
}</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/extras/SoundAppender.java</td>
<td><a href="./xref/org/apache/log4j/extras/SoundAppender.html#47">47</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/varia/SoundAppender.java</td>
<td><a href="./xref/org/apache/log4j/varia/SoundAppender.html#44">44</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>public final class SoundAppender extends AppenderSkeleton {

	private AudioClip clip;
	private String audioURL;

	public SoundAppender() {
	}

	/**
	 * Attempt to initialize the appender by creating a reference to an AudioClip.
	 * 
	 * Will log a message if format is not supported, file not found, etc.
	 * 
	 */
	public void activateOptions() {
		/*
		 * AudioSystem.getAudioInputStream requires jdk 1.3,
		 * so we use applet.newaudioclip instead
		 *
		 */
		try {
			clip = Applet.newAudioClip(new URL(audioURL));
		} catch (MalformedURLException mue) {
            LogLog.error(&quot;unable to initialize SoundAppender&quot;, mue);}
		if (clip == null) {
		      LogLog.error(&quot;Unable to initialize SoundAppender&quot;);
		}
	}

	/**
	 * Accessor
	 * 
	 * @return audio file
	 */
	public String getAudioURL() {
		return audioURL;
	}

	/**
	 * Mutator - common format for a file-based url:
	 * file:///c:/path/someaudioclip.wav
	 * 
	 * @param audioURL
	 */
	public void setAudioURL(String audioURL) {
		this.audioURL = audioURL;
	}

	/**
	 * Play the sound if an event is being processed
	 */
	protected void append(LoggingEvent event) {
		if (clip != null) {
			clip.play();
		}
	}

	public void close() {
		//nothing to do
	}

    /**
     * Gets whether appender requires a layout.
     * @return false
     */
  public boolean requiresLayout() {
      return false;
  }

}</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/rolling/helper/GZCompressAction.java</td>
<td><a href="./xref/org/apache/log4j/rolling/helper/GZCompressAction.html#60">60</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/rolling/helper/ZipCompressAction.java</td>
<td><a href="./xref/org/apache/log4j/rolling/helper/ZipCompressAction.html#61">61</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>  public ZipCompressAction(
    final File source, final File destination, final boolean deleteSource) {
    if (source == null) {
      throw new NullPointerException(&quot;source&quot;);
    }

    if (destination == null) {
      throw new NullPointerException(&quot;destination&quot;);
    }

    this.source = source;
    this.destination = destination;
    this.deleteSource = deleteSource;
  }

  /**
   * Compress.
   * @return true if successfully compressed.
   * @throws IOException on IO exception.
   */
  public boolean execute() throws IOException {
    return execute(source, destination, deleteSource);
  }

  /**
   * Compress a file.
   *
   * @param source file to compress, may not be null.
   * @param destination compressed file, may not be null.
   * @param deleteSource if true, attempt to delete file on completion.  Failure to delete
   * does not cause an exception to be thrown or affect return value.
   * @return true if source file compressed.
   * @throws IOException on IO exception.
   */
  public static boolean execute(
    final File source, final File destination, final boolean deleteSource)
          throws IOException {
    if (source.exists()) {
      FileInputStream fis = new FileInputStream(source);
      FileOutputStream fos = new FileOutputStream(destination);</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/rolling/RollingFileAppender.java</td>
<td><a href="./xref/org/apache/log4j/rolling/RollingFileAppender.html#245">245</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/rolling/RollingFileAppender.java</td>
<td><a href="./xref/org/apache/log4j/rolling/RollingFileAppender.html#292">292</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>              this.qw = createQuietWriter(newWriter);

              boolean success = true;

              if (rollover.getSynchronous() != null) {
                success = false;

                try {
                  success = rollover.getSynchronous().execute();
                } catch (Exception ex) {
                  exception = ex;
                }
              }

              if (success) {
                if (rollover.getAppend()) {
                  fileLength = new File(rollover.getActiveFileName()).length();
                } else {
                  fileLength = 0;
                }

                if (rollover.getAsynchronous() != null) {
                  lastRolloverAsyncAction = rollover.getAsynchronous();
                  new Thread(lastRolloverAsyncAction).start();
                }</pre>
</div>
</td></tr>
</table>
<table class="bodyTable"><tr class="a"><th>File</th>
<th>Line</th>
</tr>
<tr class="b"><td>org/apache/log4j/rule/LevelEqualsRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/LevelEqualsRule.html#64">64</a></td>
</tr>
<tr class="a"><td>org/apache/log4j/rule/LevelInequalityRule.java</td>
<td><a href="./xref/org/apache/log4j/rule/LevelInequalityRule.html#57">57</a></td>
</tr>
<tr class="b"><td colspan='2'><div class="source"><pre>    }

    /**
     * Populate list of levels.
     */
    private static void populateLevels() {
        levelList = new LinkedList();

        levelList.add(Level.FATAL.toString());
        levelList.add(Level.ERROR.toString());
        levelList.add(Level.WARN.toString());
        levelList.add(Level.INFO.toString());
        levelList.add(Level.DEBUG.toString());
		Level trace = Level.toLevel(5000, null);
		if (trace != null) {
			levelList.add(trace.toString());
		}</pre>
</div>
</td></tr>
</table>
</div>

      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xleft">Copyright &#169;                    2010
                        <a href="http://www.apache.org">The Apache Software Foundation</a>.
                  
        
       Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache Software License, Version 2.0</a>.</div>
      <div class="xleft">Apache Extras Companion for Apache log4j, Apache log4j, Apache, the Apache feather logo,
   the Apache Logging Services project logo, the log4j logo, and the Built by Maven logo are trademarks of The Apache Software Foundation.</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
