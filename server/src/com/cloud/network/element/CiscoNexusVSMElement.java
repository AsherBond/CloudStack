// Copyright 2012 Citrix Systems, Inc. Licensed under the
// Apache License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  Citrix Systems, Inc.
// reserves all rights not expressly granted by the License.
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// Automatically generated by addcopyright.py at 04/03/2012
package com.cloud.network.element;

import java.util.List;

import javax.ejb.Local;

import org.apache.log4j.Logger;

import com.cloud.agent.AgentManager;
import com.cloud.api.commands.AddCiscoNexusVSMCmd;
import com.cloud.api.commands.DeleteCiscoNexusVSMCmd;
import com.cloud.api.commands.ListCiscoNexusVSMCmd;
import com.cloud.api.commands.ListCiscoNexusVSMNetworksCmd;
import com.cloud.api.response.CiscoNexusVSMResponse;
import com.cloud.configuration.ConfigurationManager;
import com.cloud.configuration.dao.ConfigurationDao;
import com.cloud.dc.dao.DataCenterDao;
import com.cloud.host.dao.HostDao;
import com.cloud.host.dao.HostDetailsDao;
import com.cloud.network.CiscoNexusVSMDeviceVO;
import com.cloud.network.CiscoNexusVSMDeviceManagerImpl;
import com.cloud.network.NetworkManager;
import com.cloud.network.dao.NetworkDao;
import com.cloud.network.dao.NetworkServiceMapDao;
import com.cloud.network.dao.PhysicalNetworkDao;
import com.cloud.network.resource.CiscoNexusVSMResource;
import com.cloud.resource.ServerResource;
import com.cloud.utils.component.Inject;
import com.cloud.network.PortProfile;

@Local(value = NetworkElement.class)
public class CiscoNexusVSMElement extends CiscoNexusVSMDeviceManagerImpl implements CiscoNexusVSMElementService {

    private static final Logger s_logger = Logger.getLogger(CiscoNexusVSMElement.class);

    @Inject
    NetworkManager _networkManager;
    @Inject
    ConfigurationManager _configMgr;
    @Inject
    NetworkServiceMapDao _ntwkSrvcDao;
    @Inject
    AgentManager _agentMgr;
    @Inject
    NetworkManager _networkMgr;
    @Inject
    HostDao _hostDao;
    @Inject
    DataCenterDao _dcDao;
    
    
    //@Inject
    //CiscoNexusVSMDeviceDao _vsmDeviceDao;
    
    @Inject
    PhysicalNetworkDao _physicalNetworkDao;
    @Inject
    NetworkDao _networkDao;
    @Inject
    HostDetailsDao _detailsDao;
    @Inject
    ConfigurationDao _configDao;
    
    
    public CiscoNexusVSMDeviceVO addCiscoNexusVSM(AddCiscoNexusVSMCmd cmd) {
    
    	// This function essentially prepares all the parameters we need to send
    	// to the addCiscoNexusVSM() function defined in CiscoNexusVSMDeviceManagerImpl.java.
    	
    	// We have this separation of functionality between CiscoNexusVSMElement.java
    	// to address multiple versions of Cisco Nexus Switches in future. This is the
    	// function/layer that will parse multiple versions and accordingly prepare
    	// different parameters to pass to to the CiscoNexusVSMDeviceManagerImpl functions
    	// which will inturn talk to the right resource via the appropriate manager.
    	
    	
    	// Check if we have already added this device.
    	// Throw exception saying already added.
    	
    	// Put any checks here, return error/null if you find any.

        String vsmipaddress = cmd.getIpAddr();
        String vsmusername = cmd.getUsername();
        String vsmpassword = cmd.getPassword();
        
        // First, connect to the VSM. Then, issue a hello to it. Then, when
        // we're happy that the VSM has responded return success. Return exception
        // if failure is encountered.
        
           
        // do we need this parsing of the URL???
        // UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);
        

        // Call the XML RPC calling routine here! Define it in CiscoNexusVSMDeviceManagerImpl.java
        // In this function, we'll connect to the VSM, then absorb all its information, and populate
        // our database with the params we need.
        
        // We may want to pull the port profile info from the VSM, and their corresponding port group info from vCenter,
        // and then call a func like addPortProfile() that would write this info out to the CS db. We could have
        // similar functions like delPortProfile()/ modifyPortProfile(). We should probably also expose APIs to call
        // those functions explicitly. We could also make the pulling of port groups' info from vCenter a separate command.
        
        //CiscoNexusVSMDeviceVO vsmDeviceVO = addCiscoNexusVSM(cmd.getPhysicalNetworkId(), cmd.getUrl(), cmd.getUsername(), cmd.getPassword(), deviceName, (ServerResource) new NetscalerResource());
        
        //ExternalLoadBalancerDeviceVO lbDeviceVO = addExternalLoadBalancer(cmd.getPhysicalNetworkId(), cmd.getUrl(), cmd.getUsername(), cmd.getPassword(), deviceName, (ServerResource) new NetscalerResource());
        //return lbDeviceVO;
        
        // Invoke the addCiscoNexusVSM() function defined in the upper layer (DeviceMgrImpl).
        // The  upper layer function will create a resource of type "host" to represent this VSM. It will add this VSM to the db.
        CiscoNexusVSMDeviceVO vsmDeviceVO = addCiscoNexusVSM(cmd.getIpAddr(), cmd.getUsername(), cmd.getPassword(), (ServerResource) new CiscoNexusVSMResource());
        return vsmDeviceVO;
    }

    public boolean deleteCiscoNexusVSM(DeleteCiscoNexusVSMCmd cmd) {    
        
    	// Call the XML RPC calling routine here! Define it in CiscoNexusVSMDeviceManagerImpl.java 
        //return deleteExternalLoadBalancer(lbDeviceVo.getHostId());
    	// We have to clean up our db, remove any resources allocated, any threads listening etc..
    	// We may have to raise events to notify other components too that this VSM has been cleanly
    	// deleted, so no HA kicks in in case we are in control.
    	return true;
    }
    

    public List<? extends PortProfile> listNetworks(ListCiscoNexusVSMNetworksCmd cmd) {
    
    	/***
    	// Get the device id of the VSM from the database.
    	Long vsmDeviceId = cmd.getvsmDeviceId();
    	
    	// Get all details of the VSM by firing a dao find (querying the db). 
    	CiscoNexusVSMDeviceVO vsmDeviceVo = _lbDeviceDao.findById(vsmDeviceId);
    	
        List<PortProfileVO> portProfileMap = _networkLBDao.listByLoadBalancerDeviceId(lbDeviceId);
        if (networkLbMaps != null && !networkLbMaps.isEmpty()) {
            for (NetworkExternalLoadBalancerVO networkLbMap : networkLbMaps) {
                NetworkVO network = _networkDao.findById(networkLbMap.getNetworkId());
                networks.add(network);
            }
        }
        
        return networks;
        ***/
    	return null;
    }

    public List<CiscoNexusVSMDeviceVO> listCiscoNexusVSMs(ListCiscoNexusVSMCmd cmd) {
    	return null;
    	
    }

    public CiscoNexusVSMResponse createCiscoNexusVSMResponse(CiscoNexusVSMDeviceVO lbDeviceVO) {
    	return null;
    }
    
    public String getPropertiesFile() {
    	return null;
    }
}